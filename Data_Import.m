% function data = Data_Import
% This script calls the 'IMUImport' function which imports data from text
% files generated by the Xsens Awinda motion capture sensors using the MTw
% StationManager. This function puts the data into a cell array called
% 'data' and saves it under the name 'Trial Data Imported.' Each row of 
% 'data' corresponds to a given file. The first column of 'data'
% corresponds to the file name, the second column contains a matrix of the
% values of the file's data table, and the third column contains matrices
% that specifically contain the file's quaternion outputs.

% DIR = pwd;
% cd(fullfile(DIR,'/Subject Information'))
% disp('Load subject information ("P_xxx_Info.mat")')
% [SOfile SOdir] = uigetfile;
% load(fullfile(SOdir,SOfile))
% clc
% 
% cd(fullfile(DIR,'/Subject IMU Data Text Files'))
% disp('Select trial folder')
% TDdir = uigetdir;
% cd(DIR)
close all

baseDir = '/Users/maarten/sciebo/ZIM Smart Tech-Tic Projectbox/WWU/';
dataDir = '/Users/maarten/sciebo/ZIM Smart Tech-Tic Projectbox/Testmessung 2023-09-06/WWU/DOT data';

fnameContainsSensor  =   {
    'R lower leg';...
    'R upper leg'
    'L lower leg';...
    'L upper leg'
    };

% [filename, dataDir, filterindex] = uigetfile('*.csv', 'Pick a calibration file');

pat = digitsPattern(6);
% fnameContainsTime = extract(filename,pat);
% fnameContainsTime = fnameContainsTime(2);
fnameContainsTime = '124756';
dirContents = dir(fullfile(dataDir));

[data, span] = getIMUData(dirContents,fnameContainsSensor,fnameContainsTime);


% Acceleration
AccRThigh = data.acc.R_upper_leg(1:span,:); % Low Thigh Anterior
AccRShin = data.acc.R_lower_leg(1:span,:);
AccLThigh = data.acc.L_upper_leg(1:span,:); % Low Thigh Anterior
AccLShin = data.acc.L_lower_leg(1:span,:);

%Acceleration without gravity
stillpoint = 1;
AccRShin_noG = AccRShin - AccRShin(stillpoint,:);
AccRThigh_noG = AccRThigh - AccRThigh(stillpoint,:);
AccLShin_noG = AccLShin - AccLShin(stillpoint,:);
AccLThigh_noG = AccLThigh - AccLThigh(stillpoint,:);

% AccRNet = sqrt(sum(AccRShin_noG.^2,2))+sqrt(sum(AccRThigh_noG.^2,2));


% Rotational Velocity
RotRThigh = data.gyr.R_upper_leg(1:span,:);
RotRShin = data.gyr.R_lower_leg(1:span,:);
RotLThigh = data.gyr.L_upper_leg(1:span,:);
RotLShin = data.gyr.L_lower_leg(1:span,:);


% RotRNet = sqrt(sum(RotRShin.^2,2))+sqrt(sum(RotRThigh.^2,2));

staticTru = 1;
% Defining regions of still standing
%The user will be prompted to click two points on the heel acceleration
%plot corresponding to the range of time when the subject is standing
%still and when the subject is seated.
[RangeStand,RangeSit] = StationaryCalibrationRanges(AccRShin);

%% Perform estimations of anatomical axes: Method 2, stationary calibration
%This calibration method uses two vectors obtained from gravitational
%acceleration while the subject is stationary. The first vector is obtained
%when the subject is standing still and, like with the previous method,
%this vector is assumed to lie on the superior-inferior axis. The second
%vector is obtained when the subject is sitting whith their legs stretched
%out and their torso leaned back. The vectors obtained in this manner are
%co-planer to the vectors obtained when the subject is standing. A cross
%product is taken between the seated and standing vectors to define the
%medial-lateral axis. Another cross product is taken between the
%medial-lateral and superior-inferior vectors to get the anterior-posterior
%vector. Further cross products between these three vectors are performed
%to make sure the coordinate system being defined is orthogonal.

clc
if staticTru == 1
    clear Zero
    % R Thigh
    [SI_RThigh,ML_RThigh,AP_RThigh] = Axis_Estimation_stationary(AccRThigh,RangeStand,RangeSit);
    Zero.RThigh = [SI_RThigh; ML_RThigh; AP_RThigh];
    % R Shin 
    [SI_RShin,ML_RShin,AP_RShin] = Axis_Estimation_stationary(AccRShin,RangeStand,RangeSit);
    Zero.RShinBone = [SI_RShin;ML_RShin;AP_RShin];
    % L Thigh
    [SI_LThigh,ML_LThigh,AP_LThigh] = Axis_Estimation_stationary(AccLThigh,RangeStand,RangeSit);
    Zero.LThigh = [SI_LThigh; ML_LThigh; AP_LThigh];
    % L Shin 
    [SI_LShin,ML_LShin,AP_LShin] = Axis_Estimation_stationary(AccLShin,RangeStand,RangeSit);
    Zero.LShinBone = [SI_LShin;ML_LShin;AP_LShin];
    
    %% Save static calibration file
    disp('Save the static calibration file')
    
    % uisave('Zero')
    save('/Users/maarten/sciebo/ZIM Smart Tech-Tic Projectbox/Testmessung 2023-09-06/WWU/Calibration.mat','Zero')
    clc
end


% [filename, dataDir, filterindex] = uigetfile('*.csv', 'Pick a measurement file');


dataDirContents = dir(dataDir);
dataDirContents = {dataDirContents.name}
dataDirContents = setdiff(dataDirContents, {'.', '..'});

Start_Pat = "20230906_";
End_Pat = ".csv";
measurementTimes = extractBetween(dataDirContents,Start_Pat,End_Pat);
measurementTimes = unique(measurementTimes);

% pat = digitsPattern(6);
% fnameContainsTime = extract(filename,pat);
% fnameContainsTime = fnameContainsTime(2);

% dirContents = dir(fullfile(dataDir));

for iMeasurement = 1:length(measurementTimes)

    fprintf('%s...\n',measurementTimes{iMeasurement})
    try

        [data, span] = getIMUData(dir(dataDir),fnameContainsSensor,measurementTimes(iMeasurement));


        %% Perform Rotations on Body Segment Coordinate Systems
        % This section performs calculations to rotate initial unit vectors
        % provided by the calibration file using the quaternion outputs of the
        % sensors. The result is a series of coordinate systems defined by
        % orthogonal unit vectors that are rotated so that at each time point they
        % describe the orientation of the given sensor in space. This is performed
        % by the 'CoordinateTransformQuatPreSpecifiedAxes' function which takes the
        % quaternions and the three orthogonal unit vectors of a given sensor as
        % input. The quaternions are referenced in the cell array 'data' using the
        % index variable 'ind' (which corresponds to the first row of a given task)
        % plus some number corresponding to the order of the sensors based on
        % Matlab's numeric/alphabetical ordering scheme. After the sensor
        % coordinate systems are rotated another function,
        % 'RotMatTransformToGlobal' rotates the coordinate system of a given sensor
        % at every time point so that it is in line with the global coordinate
        % system at the beginning of the trial when all of the coordinate systems
        % of all of the sensors are more or less in line with each other.
        FR = 60;
        OffsetPoint = 10;


        % R shin
        shinRSI = data.acc.R_lower_leg(OffsetPoint,:)./norm(data.acc.R_lower_leg(OffsetPoint,:));
        shinRML = Zero.RShinBone(2,:);
        shinRAP = cross(shinRSI,shinRML);

        RShankCoord.ShinBone = CoordinateTransformQuatPreSpecifiedAxes(data.quat.R_lower_leg(1:span,:),shinRSI,shinRML,shinRAP);
        [RShankCoord.ShinBone.Axis1,RShankCoord.ShinBone.Axis2,RShankCoord.ShinBone.Axis3] = RotMatTransformToGlobal( ...
            RShankCoord.ShinBone.Axis1(:,OffsetPoint),RShankCoord.ShinBone.Axis2(:,OffsetPoint),RShankCoord.ShinBone.Axis3(:,OffsetPoint), ...
            RShankCoord.ShinBone.Axis1,RShankCoord.ShinBone.Axis2,RShankCoord.ShinBone.Axis3);
        RShankSensors = fieldnames(RShankCoord);

        % R thigh
        thighRSI = data.acc.R_upper_leg(OffsetPoint,:)./norm(data.acc.R_upper_leg(OffsetPoint,:));
        thighRML = Zero.RThigh(2,:);
        thighRAP = cross(thighRSI,thighRML);

        RThighCoord.thigh = CoordinateTransformQuatPreSpecifiedAxes(data.quat.R_upper_leg(1:span,:),thighRSI,thighRML,thighRAP);
        [RThighCoord.thigh.Axis1,RThighCoord.thigh.Axis2,RThighCoord.thigh.Axis3] = RotMatTransformToGlobal( ...
            RThighCoord.thigh.Axis1(:,OffsetPoint),RThighCoord.thigh.Axis2(:,OffsetPoint),RThighCoord.thigh.Axis3(:,OffsetPoint), ...
            RThighCoord.thigh.Axis1,RThighCoord.thigh.Axis2,RThighCoord.thigh.Axis3);
        RThighSensors = fieldnames(RThighCoord);

        % L shin
        shinLSI = data.acc.L_lower_leg(OffsetPoint,:)./norm(data.acc.L_lower_leg(OffsetPoint,:));
        shinLML = Zero.LShinBone(2,:);
        shinLAP = cross(shinLSI,shinLML);

        LShankCoord.ShinBone = CoordinateTransformQuatPreSpecifiedAxes(data.quat.L_lower_leg(1:span,:),shinLSI,shinLML,shinLAP);
        [LShankCoord.ShinBone.Axis1,LShankCoord.ShinBone.Axis2,LShankCoord.ShinBone.Axis3] = RotMatTransformToGlobal( ...
            LShankCoord.ShinBone.Axis1(:,OffsetPoint),LShankCoord.ShinBone.Axis2(:,OffsetPoint),LShankCoord.ShinBone.Axis3(:,OffsetPoint), ...
            LShankCoord.ShinBone.Axis1,LShankCoord.ShinBone.Axis2,LShankCoord.ShinBone.Axis3);
        LShankSensors = fieldnames(LShankCoord);

        % L thigh
        thighLSI = data.acc.L_upper_leg(OffsetPoint,:)./norm(data.acc.L_upper_leg(OffsetPoint,:));
        thighLML = Zero.LThigh(2,:);
        thighLAP = cross(thighLSI,thighLML);

        LThighCoord.thigh = CoordinateTransformQuatPreSpecifiedAxes(data.quat.L_upper_leg(1:span,:),thighLSI,thighLML,thighLAP);
        [LThighCoord.thigh.Axis1,LThighCoord.thigh.Axis2,LThighCoord.thigh.Axis3] = RotMatTransformToGlobal( ...
            LThighCoord.thigh.Axis1(:,OffsetPoint),LThighCoord.thigh.Axis2(:,OffsetPoint),LThighCoord.thigh.Axis3(:,OffsetPoint), ...
            LThighCoord.thigh.Axis1,LThighCoord.thigh.Axis2,LThighCoord.thigh.Axis3);
        LThighSensors = fieldnames(LThighCoord);
    catch
        fprintf('something failed (%s)...\n',measurementTimes{iMeasurement})
        continue
    end

    %% Set up plotting colors and line styles
    % These variables are used later in plotting to generate unique plots for
    % every sensor combination. Each sensor above the joint is given a unique
    % color and every sensor below the joint is given a unique line style.
    colors = {'r','b','g','k'};
    lines = {'-','--','-.',':'};

    %% Knee Angles
    % The knee Euler angles are calculated using the 'KneeEulerAngle' function
    % and plotted. This is done for every possible sensor combination on the
    % same figure. A legend is provided listing every combination.
    % if KneeOpt == 1
    figure("Name",measurementTimes{iMeasurement})
    
    RKneeLegend = cell(length(RThighSensors)*length(RShankSensors),1);
    LKneeLegend = cell(length(LThighSensors)*length(LShankSensors),1);
    legInd = 1;
    for ee = 1:length(RShankSensors)
        for ff = 1:length(RThighSensors)

            RShC = RShankCoord.(RShankSensors{ee});
            RThC = RThighCoord.(RThighSensors{ff});
            LShC = LShankCoord.(LShankSensors{ee});
            LThC = LThighCoord.(LThighSensors{ff});

            RKneeLegend{legInd} = strcat('Shank',32,RShankSensors{ee},32,'/',32,'Thigh',32,RThighSensors{ff});
            LKneeLegend{legInd} = strcat('Shank',32,LShankSensors{ee},32,'/',32,'Thigh',32,LThighSensors{ff});

            [flexangRKnee{ee,ff},abdangRKnee{ee,ff},rotangRKnee{ee,ff}] = AnglesYXZ(RThC.Axis1,RThC.Axis2,RThC.Axis3, ...
                RShC.Axis1,RShC.Axis2,RShC.Axis3,[0 -1 0],[0 0 1]);
            [flexangLKnee{ee,ff},abdangLKnee{ee,ff},rotangLKnee{ee,ff}] = AnglesYXZ(LThC.Axis1,LThC.Axis2,LThC.Axis3, ...
                LShC.Axis1,LShC.Axis2,LShC.Axis3,[0 -1 0],[0 0 1]);

            RKnee_Names{ee,ff} = RKneeLegend{legInd};
            LKnee_Names{ee,ff} = LKneeLegend{legInd};
            legInd = legInd + 1;
            %   Flexion
            subplot(3,2,1)
            hold on
            plot(linspace(0,(1/FR)*length(flexangLKnee{ee,ff}),length(flexangLKnee{ee,ff})),flexangLKnee{ee,ff},strcat(colors{ee},lines{ff}))
            title(strcat('Knee Angles',10,'Flexion'))
            ylabel('Degrees')
            hold off
            subplot(3,2,2)
            hold on
            plot(linspace(0,(1/FR)*length(flexangRKnee{ee,ff}),length(flexangRKnee{ee,ff})),flexangRKnee{ee,ff},strcat(colors{ee},lines{ff}))
            title(strcat('Knee Angles',10,'Flexion'))
            ylabel('Degrees')
            hold off

            %   Abduction
            subplot(3,2,3)
            hold on
            plot(linspace(0,(1/FR)*length(abdangLKnee{ee,ff}),length(abdangLKnee{ee,ff})),abdangLKnee{ee,ff},strcat(colors{ee},lines{ff}))
            title('Abduction')
            ylabel('Degrees')
            hold off
            subplot(3,2,4)
            hold on
            plot(linspace(0,(1/FR)*length(abdangRKnee{ee,ff}),length(abdangRKnee{ee,ff})),abdangRKnee{ee,ff},strcat(colors{ee},lines{ff}))
            title('Abduction')
            ylabel('Degrees')
            hold off

            %   Rotation
            subplot(3,2,5)
            hold on
            plot(linspace(0,(1/FR)*length(rotangLKnee{ee,ff}),length(rotangLKnee{ee,ff})),rotangLKnee{ee,ff},strcat(colors{ee},lines{ff}))
            title('Rotation')
            ylabel('Degrees')
            hold off
            subplot(3,2,6)
            hold on
            plot(linspace(0,(1/FR)*length(rotangRKnee{ee,ff}),length(rotangRKnee{ee,ff})),rotangRKnee{ee,ff},strcat(colors{ee},lines{ff}))
            title('Rotation')
            ylabel('Degrees')
            hold off
        end
    end

    hold on
    subplot(3,2,1)
    legend(RKneeLegend)
    hold off
end
    
% end


function [data,span] = getIMUData(dirContents,fnameContainsSensor,fnameContainsTime)

for iS = 1:length(fnameContainsSensor)

    iMatch = find(contains({dirContents.name},fnameContainsTime) & contains({dirContents.name},fnameContainsSensor{iS}));

    sensorVarName = fnameContainsSensor{iS};
    sensorVarName(fnameContainsSensor{iS} == ' ') = '_';

    fpath = fullfile(dirContents(iMatch).folder,dirContents(iMatch).name);
    % data_temp = readtable(fpath, 'NumHeaderLines', 7, 'ExpectedNumVariables',16);
    data_temp = readtable(fpath);
    SampleTimeFine{iS,:} = data_temp.SampleTimeFine;
end

intersect12 = intersect(SampleTimeFine{1},SampleTimeFine{2});
intersect123 = intersect(intersect12,SampleTimeFine{3});
intersect1234 = intersect(intersect123,SampleTimeFine{4});


for iS = 1:length(fnameContainsSensor)

    iMatch = find(contains({dirContents.name},fnameContainsTime) & contains({dirContents.name},fnameContainsSensor{iS}));

    sensorVarName = fnameContainsSensor{iS};
    sensorVarName(fnameContainsSensor{iS} == ' ') = '_';

    fpath = fullfile(dirContents(iMatch).folder,dirContents(iMatch).name);
    % data_temp = readtable(fpath, 'NumHeaderLines', 7, 'ExpectedNumVariables',16);
    data_temp = readtable(fpath);

    [~,ia,~]=intersect(data_temp.SampleTimeFine,intersect1234);

    quat = [data_temp.Quat_W, data_temp.Quat_X, data_temp.Quat_Y, data_temp.Quat_Z];
    data.quat.(sensorVarName) = quat(ia,:);
    acc = [data_temp.Acc_X, data_temp.Acc_Y, data_temp.Acc_Z];
    data.acc.(sensorVarName) = acc(ia,:);
    gyro = [data_temp.Gyr_X, data_temp.Gyr_Y, data_temp.Gyr_Z];
    data.gyr.(sensorVarName) = gyro(ia,:);

end


span = min([length(data.acc.R_lower_leg) length(data.acc.R_upper_leg)]);

end
